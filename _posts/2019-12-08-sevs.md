---
layout: post
categories: posts
title: A Secure electronic voting system
tags: [ programming networks ]
date-string: January 2, 2021
---
<img src="/images/sevs/secure-voting.jpg" alt="Secure electronic voting system" width="300">
<br>


## Background

Ok so E-Voting is not a new idea, at all. Apparently 7 US states used some sort of automation even way back in the 1964 presedential election. Today, its actually used in various forms across the world, and some countries even use it for national and parliamentary elections. However, totally reliable and secure electronic voting seems like a bit of holy grail. I think most people are in agreement that it would be a positive development to the electoral systems themselves, but similarly every computer scientist and security researcher has warned against the sheer impossibility of guaranteeing against all possible security flaws and vulnerabilities. I guess that doesnt necessarilly mean its never gonna see wide adoption, but I tend to think that if a new technology is gonna be a hit, its gotta happen fairly quickly after its release. It might be similar to being accused of a crime you didnt commit, once the doubt sets in, its pretty hard to get rid of. And the more serious the crime (or the higher the stakes in the election), it becomes almost impossible to resolve all the residual uncertainty, and in case you were wondering, pairing e-voting with manual voting and giving voters the choice doesnt solve much either. Theres a bunch of different types of e-voting, but one of the main distinctions is the hardware (dedicated device vs computer/web-based), and each has its advantages. Interestingly, some secrity experts claim the problem is not with e-voting, but the inherent unpredictability of computational systems themselves. To be honest, that seems completely ridiculous to me, sure computers can crash randomly or have some untraceable bug, but so can humans ? And the latter actually seems a lot more likely. 

I dont doubt that security experts have found security problems in every attempt at online voting, and yes some of these problems simply dont exist in the manual system, but on the whole im not convinced that the traditional system has less flaws.

<br>

I think because a lot of people are gonna naturally cautious anyway about any e-voting system, whatever system is used has got to be really really good, and tick all the boxes. Traditional manual voting is definitely susceptible to vote manipulation, miscounting, and so many other security risks. But an e-voting system cant go near any of that stuff, Its gotta be anonymous,  accurate, private, tamper-proof, auditable, consistent, available, distributed, and a lot more. Oh, and its gotta do all this whilst also being simple and transparent, and *actually usable to the general public whilst also robust to the general public*.

<br>

Given all that, I thought it would be fun to come up with my own system design and code my own implementation of an evoting system. 
Im usually a big fan of keeping things simple, I think its pretty much always a positive attribute to have for several reasons. Having said that, looking back on the same great iventions over the past few hundred years, some of the best ones are extremely complex, which gives me a bit of hope that I didnt totally waste my time trying to create something totally pointless.


## Temporal stages of the whole election

Ill start by first going over the 6 sequential phases during which the election takes place, and a winner is announced:

1. #### Before registration
All services are unavailable, other than information on where/when to register.

2. #### Registration
All voters must register to vote, providing identity credentials and in return receiving a set of single use keys to authorize the vote.

3. #### Redistribution/shuffle (A)
There are two resdistribution/shuffle stages, and each of them roughly conist of three sub-stages
    a) **Anonymising** - This means hashing and encrypting all information sent by individual voters.

    b) **Shuffling** - Randomly shuffling the association between who the *voter* is and who the *vote is for*.

    c) **Restributing** - Randomly distributing the data across different physical servers.

4. #### Voting
All registered voters uses the credentials they obtained in stage 2 in addition to further credentials in a highly specific, verbose, and deliberately fragile protocol to cast 
their vote for their chose candidate

5. #### Redistribution/shuffle (B)

6. ### Counting and Sorting
- Votes are counted across multiple distributed servers and the results are collected. The results are not collected and sorted, but rather a consensus is reached across all servers and the winner is decided through an election leadership protocol.
- Individual votes are then published so the result can be publicly verified.


<figure  style="text-align:center">
    <img src="/images/sevs/temporal_stages.png" alt="The six tempopral stages of the electronic election">
    <figcaption>The 6 temporal strages of the electronic election</figcaption>
</figure>


## System Architecture

<figure  style="text-align:center">
    <img src="/images/sevs/system_architecture.png" alt="secure electronic voting system architecture">
    <figcaption>System Architecture</figcaption>
</figure>

The proposed system architecture for this electronic voting system is shown in the diagram above. As you can hopefully see, its not that complicated. This diagram is a pretty big simplification, and doesnt include quite a few infrastructure features such as private subnets, and it also doesnt show the flow of data and order of events/protocols, but I think its a good starting point. Anyway, its not like I even know the complete picture myself, but some key points to note from this diagram are:

- This a web based system, and so does not rely on dedicated voting machines. 

- There are two 'groups' of servers, the registration servers and the voting servers.

- Each group is scalable individually, so there are potentially hundreds or thousands of registration servers, and a similar (but not necessarilly the same) number of voting servers.

- Similar to MFA, The client performs the registration protocol by interfacing with a sequence of (at least 2) registration servers, and the whole registration process (i.e the combined sequence of registration protocols) requires the client to use at least 2 devices, and the perform the complete protocol sequence with each device. 

## Protocols

Ok, so now lets go through each of the temporal stages individually and illustrate (with the help of diagrams of course) the protocol(s) involved at each stage.

### Before Registration.
Nothing much to say here, everything is closed, any attempt to register or vote will error with instructions on how to register 
and what documents are required. 

### Registration

As I mentioned above, the registration protocol actually takes place with the client interfacing with a sequence of *n*  registration servers (where n >= 2). The whole protocol sequence must then be performed *i* times (where i >= 2), each time using a different client device. The values of *n* and *i* dont have to be correlated, but the higher the value of *n* and *i*, the higher the security guarantees.


#### The registration protocol sequence

The registration protocol sequence works somewhat like this.

1. The client (voter) receives in the physical post their polling card as they usually would do, and they use a password present in the envelope (similar to the letter the bank sends you with your pin when you order a new bank card), and in response they send (to any of the registration servers) the password they received in the post, documents verifying their identity such as their passport and a proof of address, as well as a randomly generated client nonce




On receiving any request, the server passes the request to a timer gateway (which holds information about the designated registration time) and which look will the current time, and then either reject the client, or forward it to the registration service (probably on the same physical server) if the request is made within the registration hour. The request message is then read in full, validated and parsed. A valid request can only be a key request at this stage, where the clients ID number, configured in a configuration file or something (indicating that this client id allowed to register) is sent as a header with the request. An internal dictionary data structure, is checked to see if this ID has already made a previous failed or succesfull request, and a new nonce is generated and sent back to the client, along with the public key of the server accordingly.

3. #### Transfer Time
    The mapping from ID numbers of registered voters to nonces is hashed (each ID number and nonce is hashed individually, so the map retains its structure) and the result is sent to the authentication
    server.
4. #### Voting hour
    Similar to the registration hour, a timer gateway will only accept the request if it is made within the voting hour.
    When a vote is requested, the message must contain 4 headers: Hash(ID),
    Hash(Nonce), Hash(ID, Nonce, pubkey(Vote)) - i.e the MAC code, and pubkey(vote).
    The hashed ID and nonce are checked to see if they are included in the mapping it received from the registration server. If they are, the encrypted vote is succesfully extracted from the message (whilst still encrypted), and the mapping is removed from the list.
5. #### After voting
    After Voting hour, the data the list of encrypted votes is sent back to the
    registration server, which then decrypts each of them individually,
    and sorts the list to find the winner.



#### DDoS protection
It goes without saying why we need to be able to guarantee immunity from DDos attacks, although this in itself isnt really the problem, since many companies are genuinely able to provide such a service.  Traditionally, most CDN and cloud networks rely on full-proxy, symmetric protection. But that requires full decryption of SSL communications before it is scrubbed, thereby adding latency and violating user privacy, as the decryption keys would have to be replicated on hundreds of CDN servers. In September 2021, nineteen DDoS attacks were registered against Russia’s remote electronic voting system

#### Acessibility

Essentially, everyone has actually gotta be able to use the system, and just as easily as they did before. DRE systems (like an ATM, but for recording votes) are a popular way of satisfying these requirements, but they dont solve all cases. A system where paper votes are market by hand and counted by a machine is another possibility, but in this case we lose out on some of the benefits of why we might want e-voting in the first place. This might seem trivial, but the role of social and socio-psychological factors is one of the biggest dimensions. For example, Voting from the home increases the likelihood that choices will be discussed within a limited and homogeneous group context, whereas voting in the community may open the voter up to disparate social influence from others, especially those relating to more pro-social or collectivist concerns. Thats just one example of a non-technical problem which doesnt seem like it cant be (or at least shouldnt be) solved with more technology. 


#### Confidentiality
Confidentiality in computer networks refers to protecting information from being accessed by unauthorized parties. In the case of e-voting, this translates as only the voter should be able to know who they voted for. The vote server(s), where votes are collected and counted, should be able to validate and see the value of each vote, but not associate that vote back to the original voter, and all other parties should not be able to discern either. In traditional voting, Confidentiality is done easily through physical seperation, but in computer networks this is usually achieved through a combination of cryptographic hash functions, D-H key exchanges, and assymetric keys. Some propososed systems try to mimmick this seperationwith geographically remote servers for the different processes of voter registration, vote sorting, collecting and counting. Crucially, communication between these different processes is restricted. 

#### Anonymity and privacy
<a href="https://en.wikipedia.org/wiki/ThreeBallot">ThreeBallot</a> is a conceptual system with some intersting security features, and in my own design I have simplified and slightly adapated the basic components of ThreeBallot to extract only the most crucial properties of voter <b>privacy</b> and <b>anonymity.</b> Similar to confidentiality, voter anonymity in this case would ensure that inspecting the content and value of any single vote would not reveal the identity of the voter. In traditional manual systems, we dont need to write our names on votes so this is not a problem, but in electronic systems, each vote must be <b>authenticated</b> as belonging to a legitimate registered voter by marking the network packet containing the vote with some preconfigured identifier. It is problematic for a vote to be both authenticated and anonmymous but in this NBallot system, each voter votes in total n times ( where n is the number of candidates ), but (n - 1) of these votes will be redundant, and the remaining vote indicates the 'real' choice of candidate. How exactly votes are indicated as redundant could vary accoriding to implememtation, and in the original ThreeBallot system used negative voting,but in my own design, there is some key (in addition to any other encryption) that can only be interpreted by the vote collecting server and may be preconfigured at the time of voter registration. Since inspecting a single vote doesnt reveal anything about the 'real' choice of candidate, we could use the preferred form of SSL proxy DDos mitigation.

#### Integrity
Integrity, in the context of computer systems, refers to methods of ensuring that data is real, accurate and safeguarded from unauthorized user modification. With traditional paper balloting and hand counting, the entire process is not only clearly visible to those observing it, but it is also easily understandable to the average voter. The ballot box can be shown to be empty at the start of voting by polling staff, then sealed, observed in the polling station to ensure that only legitimate voters are putting in ballots, and at the end of voting the seal can be broken and the ballots counted in full view of observers. Therefore, most previous work on guaranteeing integrity in e-voting systems tries to promote transparency and verifiability as tools for ensuring the integrity of votes. <b>Transparency</b> refers to how easily third parties may observe and monitor that each counting and sorting process is completed correctly.
<b>Verifiability</b> has two meanings: At the individual level, all voters should be able to
verify that their votes have been correctly recorded and have been correctly included into the tally. At the universal level, anyone in the world should be able to verify the integrity of the tallying result, based on publicly available audit data. So while ensuring that voting and counting technologies are transparent does not alone guarantee that technologies will generate accurate results, it does provide the space and tools to do so. Audit trails and voter receipts are the usual mechanisms. However, in other aspects of computer network security, crypytographic hash functions, checksums and MAC codes can be used to prove that a message has been tampered or subject to MiTM attacks. The possibility of retransmission or restoring from a back-up copy must exists in this case. In NBallot, It seems we could that we could say with a high degree of certainty that votes have at least not been tampered or corrupted in transmission because any third party know could not know how to intepret the decoy keys, and which vote represents a genuine choice. Selecting a packet in the group at random and modifying its value would also fail, since each group of n votes must be authenticated by the collecting server as conforming to the rules and format of the NBallot system. Each decoy key must be unique in that group, and each group of decoy keys is chosen by the voter at registration time, and recorded by the server. In any of these keys have been modified, or any other formatting constraint fails, the whole group is void and should be retransmitted. <b>Voter registration</b> is a prerequisite to voting whereby each personE who wishes to vote must register their intention with the electoral authorities, similar to the process of registering to vote in any election. The difference is that, in this system, each voter receives a unique identification number (Voter ID), which is then used to compute a digital signature on all of their network votes. After the election, all voter IDs and their chosen candidates could be posted on a public website. Without sacrificing voter privacy, each individual voter could verify that their own vote had been correctly recorded, and any third party may check that all votes has been counted and sorted correctly, and the correct candidate elected. The process of secure voter registration is complex and is detailed later.






 
The security requirements of such a system come in many forms, and was always going to be a major issue, but cryptography can only so far. For example, any reliable system necessity will have to be able to secure and not vulnerable to DDos attacks. Network providers like Cloudflare, Akamai, or Emblaze do provide such a service, but at the unacceptable cost of unencrypted packet inspection. 

The implementation was suppossed to satisfy coursework requirements, and so parts of it could definitely be improved. For example, my own shoddy implementation of SSL. 

> The system must allow only votes for a predefined list of candidates, and from a predefined
> list of voters, where the the two lists are equal. Votes must be anonymous and totally secure,
> so no one, neither the server(s), possible attackers on the network, nor other candidates can
> know who you have voted for.

This system can be roughly divided into 5 temporal stages, as shown in figure 1.3 below. 
1. #### Before registration
    All services are unavailable, other than information on where/when to register.
2. #### Registration
    On receiving any request, the server passes the request to a timer gateway (which holds information about the designated registration time) and which look will the current time, and then either reject the client, or forward it to the registration service (probably on the same physical server) if the request is made within the registration hour. The request message is then read in full, validated and parsed. A valid request can only be a key request at this stage, where the clients ID number, configured in a configuration file or something (indicating that this client id allowed to register) is sent as a header with the request. An internal dictionary data structure, is checked to see if this ID has already made a previous failed or succesfull request, and a new nonce is generated and sent back to the client, along with the public key of the server accordingly.
3. #### Transfer Time
    The mapping from ID numbers of registered voters to nonces is hashed (each ID number and nonce is hashed individually, so the map retains its structure) and the result is sent to the authentication
    server.
4. #### Voting hour
    Similar to the registration hour, a timer gateway will only accept the request if it is made within the voting hour.
    When a vote is requested, the message must contain 4 headers: Hash(ID),
    Hash(Nonce), Hash(ID, Nonce, pubkey(Vote)) - i.e the MAC code, and pubkey(vote).
    The hashed ID and nonce are checked to see if they are included in the mapping it received from the registration server. If they are, the encrypted vote is succesfully extracted from the message (whilst still encrypted), and the mapping is removed from the list.
5. #### After voting
    After Voting hour, the data the list of encrypted votes is sent back to the
    registration server, which then decrypts each of them individually,
    and sorts the list to find the winner.

In total there are 3+ registration servers, and a single voting server. Every client has to register with all registration servers to receives the public key of each server, and once they have registered, they must vote as many times as there registration servers, each vote in its own request and encryted with a different public key.  Each registration server then maintains a list of all clients registered on that server, and then only common entries on all registration lists will be authorised to vote. There can infact be any number of registration servers, but the more there are, the more confidently we can cofirm the true identity of the client as being on the list of pre-configured authorised voters, because, similar to 2FA, each potential voter would be told about the location and time of registration hour on each registration server via a different medium of communication. Since the the client must repeat their vote for as many registration servers as there are, each vote must be for the same candidate in order for it to be counted, and even if any two of the registration servers did communicate with each other to try and work out who had voted for who, they could not without the cooperation of all others. In conbination with an HMAC tag on each repeated vote, as the number of registration servers increases, the possibility or threat of fabrication or modification becomes negligible.

<figure  style="text-align:center">
    <img src="/images/sevs/periods.png" alt="The five time periods">
    <figcaption>The five time periods</figcaption>
</figure>

<figure  style="text-align:center">
    <img src="/images/sevs/arc1.png" alt="The two types of server">
    <figcaption>The two types of server</figcaption>
</figure>

<figure  style="text-align:center">
    <img src="/images/sevs/arc2.png" alt="A event flow for a single clients request pattern whilst registering and voting.">
    <figcaption>A event flow for a single clients request pattern whilst registering and voting.</figcaption>
</figure>

The original implementation for this project was written in Java, and the source code is available from my <a href="https://www.github.com/nfs002">Github Page</a>